/*
 * ribbon-health
 *
 * An API for interacting with the data provided by Ribbon Health, including information about healthcare providers, locations, insurances, and more. 
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 * Generated by: https://openapi-generator.tech
 */


use async_trait::async_trait;
use reqwest;
use std::sync::Arc;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration};
use crate::apis::ContentType;

#[async_trait]
pub trait PriceTransparencyApi: Send + Sync {

    /// GET /pricing/carrier/{carrier_uuid}
    ///
    /// Fetch metadata including the recency of the pricing data used for a specific carrier. 
    async fn get_pricing_carrier(&self,  params: GetPricingCarrierParams ) -> Result<ResponseContent<GetPricingCarrierSuccess>, Error<GetPricingCarrierError>>;

    /// GET /pricing/version
    ///
    /// This endpoint will the names of the carriers for which we have data. This can be used to fetch the recency of the data used per carrier.  This endpoint is deprecated. Please use [List Carriers](./getpricingcarriers) instead. 
    async fn get_pricing_carrier_names(&self, ) -> Result<ResponseContent<GetPricingCarrierNamesSuccess>, Error<GetPricingCarrierNamesError>>;

    /// GET /pricing/carriers
    ///
    /// This endpoint will show the carriers for which we have data. This can be used to fetch the recency of the data used per carrier. 
    async fn get_pricing_carriers(&self, ) -> Result<ResponseContent<GetPricingCarriersSuccess>, Error<GetPricingCarriersError>>;

    /// GET /pricing/providers/{npi}/procedures/{procedure_uuid}
    ///
    /// Find the prices offered by a single provider for a specific procedure, with a given insurance, across practice locations.  #### Example Use Case Compare insurance-specific price estimates of a Leg MRI for a single provider at multiple relevant practices (e.g., compare this provider's rates when performing the procedure at both the provider's private outpatient facility, as well as a nearby hospital system clinic where they also practice). 
    async fn get_pricing_provider_procedure(&self,  params: GetPricingProviderProcedureParams ) -> Result<ResponseContent<GetPricingProviderProcedureSuccess>, Error<GetPricingProviderProcedureError>>;

    /// GET /pricing/providers/{npi}/procedures/{procedure_uuid}/locations/{location_uuid}
    ///
    /// Search for a price estimate for a specific procedure from a specific provider at a specific location, with a given insurance plan.  #### Example Use Case Given an insurance, identify the expected price of a particular procedure from a specific provider at a known facility. 
    async fn get_pricing_provider_procedure_location(&self,  params: GetPricingProviderProcedureLocationParams ) -> Result<ResponseContent<GetPricingProviderProcedureLocationSuccess>, Error<GetPricingProviderProcedureLocationError>>;

    /// GET /pricing/providers/{npi}/procedures
    ///
    /// Fetch the list of procedures that a single provider performs, with the lowest available negotiated rates specific to a given insurance for each procedure.  #### Example Use Case For a given provider, search the full list of procedures that they are likely to perform where there are negotiated rates available for a particular insurance, and return the minimum price for each procedure. 
    async fn get_pricing_provider_procedures(&self,  params: GetPricingProviderProceduresParams ) -> Result<ResponseContent<GetPricingProviderProceduresSuccess>, Error<GetPricingProviderProceduresError>>;

    /// GET /pricing/providers
    ///
    /// Search for providers that perform a given procedure and find the lowest insurance-specific price for a procedure in your area.  #### Example Use Case Search for all applicable provider negotiated rates, given a specific insurance and procedure (and optionally, a specific location/address and distance). For example, search for all providers near me who perform Leg MRIs and who take a given insurance, sorted by lowest price. 
    async fn get_pricing_providers(&self,  params: GetPricingProvidersParams ) -> Result<ResponseContent<GetPricingProvidersSuccess>, Error<GetPricingProvidersError>>;

    /// GET /pricing/version/{carrier_name}
    ///
    /// Fetch the recency of the pricing data used for a specific carrier by name.  This endpoint is deprecated. Please use [Get Carrier](./getpricingcarrier) instead. 
    async fn get_pricing_version_carrier(&self,  params: GetPricingVersionCarrierParams ) -> Result<ResponseContent<GetPricingVersionCarrierSuccess>, Error<GetPricingVersionCarrierError>>;
}

pub struct PriceTransparencyApiClient {
    configuration: Arc<configuration::Configuration>
}

impl PriceTransparencyApiClient {
    pub fn new(configuration: Arc<configuration::Configuration>) -> Self {
        Self { configuration }
    }
}


/// struct for passing parameters to the method [`get_pricing_carrier`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct GetPricingCarrierParams {
    /// The UUID of the insurance carrier.
    pub carrier_uuid: String
}

/// struct for passing parameters to the method [`get_pricing_provider_procedure`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct GetPricingProviderProcedureParams {
    /// The 10-digit National Provider Identifier (NPI) of the healthcare provider to fetch.
    pub npi: String,
    /// The UUID of the target procedure. If the target procedure is a procedure bundle but we do not have any data for it, we will return data for its anchor procedure instead.
    pub procedure_uuid: String,
    /// Search for negotiated rates for the insurance plan with this UUID.
    pub plan_id: Option<String>,
    /// The page of the results which was returned.
    pub page: Option<i32>,
    /// How many results are in each page.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method [`get_pricing_provider_procedure_location`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct GetPricingProviderProcedureLocationParams {
    /// The 10-digit National Provider Identifier (NPI) of the healthcare provider to fetch.
    pub npi: String,
    /// The UUID of the target procedure. If the target procedure is a procedure bundle but we do not have any data for it, we will return data for its anchor procedure instead.
    pub procedure_uuid: String,
    /// The UUID of the target location.
    pub location_uuid: String,
    /// Search for negotiated rates for the insurance plan with this UUID.
    pub plan_id: Option<String>
}

/// struct for passing parameters to the method [`get_pricing_provider_procedures`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct GetPricingProviderProceduresParams {
    /// The 10-digit National Provider Identifier (NPI) of the healthcare provider to fetch.
    pub npi: String,
    /// Search for negotiated rates for the insurance plan with this UUID.
    pub plan_id: Option<String>,
    /// The page of the results which was returned.
    pub page: Option<i32>,
    /// How many results are in each page.
    pub page_size: Option<i32>
}

/// struct for passing parameters to the method [`get_pricing_providers`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct GetPricingProvidersParams {
    /// Search for prices for the procedure with the given UUID.  If the given ID is for a procedure bundle but do not have data for the insurance specified by the `plan_id` parameter, we will return data for its anchor procedure instead.  Exactly one of `procedure`, `procedure_id`, or `procedure_code` must be specified.
    pub procedure_id: Option<String>,
    /// Search for prices for the given procedure. This input is fuzzy matched to the most relevant procedure `display` field.  We will preferentially match procedure bundles. If we match a procedure bundle but do not have data for the insurance specified by the `plan_id` parameter, we will return data for its anchor procedure instead.  Exactly one of `procedure`, `procedure_id`, or `procedure_code` must be specified.
    pub procedure: Option<String>,
    /// Search for prices for procedures with the given billing code.  We will preferentially match procedure bundles. If we match a procedure bundle but do not have data for the insurance specified by the `plan_id` parameter, we will return data for its anchor procedure instead.  Exactly one of `procedure`, `procedure_id`, or `procedure_code` must be specified.
    pub procedure_code: Option<String>,
    /// The page of the results which was returned.
    pub page: Option<i32>,
    /// How many results are in each page.
    pub page_size: Option<i32>,
    /// Search for negotiated rates for the insurance plan with this UUID.
    pub plan_id: Option<String>,
    /// A comma separated list of specialty UUIDs. Filter to providers with any of the given specialties.
    pub specialty_ids: Option<String>,
    /// String input of a provider specialty that will be interpreted and matched to the single closest specialty, dealing with basic typos and colloquial names for providers.
    pub specialty: Option<String>,
    /// String input of an address that will be interpreted and geocoded in real time.
    pub address: Option<String>,
    /// Latitude/longitude pair of coordinates in lieu of a string address.
    pub location: Option<String>,
    /// The proximity radius of providers returned.
    pub distance: Option<i32>,
    /// Comma-separated list of fields within the provider object to return. Can be used to greatly reduce the size of the response by requesting only data you intend to use.  Note that all price information is nested under the `matched_location` field. You almost certainly want to return this field.  Cannot be used in tandem with `_excl_fields`.
    pub fields: Option<String>,
    /// Comma-separated list of fields within the provider object to exclude from the response. Can be used to greatly reduce the size of the response by requesting only data you intend to use.  Cannot be used in tandem with `fields`.
    pub _excl_fields: Option<String>
}

/// struct for passing parameters to the method [`get_pricing_version_carrier`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct GetPricingVersionCarrierParams {
    /// The name of the insurance carrier.
    pub carrier_name: String
}


#[async_trait]
impl PriceTransparencyApi for PriceTransparencyApiClient {
    /// Fetch metadata including the recency of the pricing data used for a specific carrier. 
    async fn get_pricing_carrier(&self,  params: GetPricingCarrierParams ) -> Result<ResponseContent<GetPricingCarrierSuccess>, Error<GetPricingCarrierError>> {
        
        let GetPricingCarrierParams {
            carrier_uuid,
        } = params;
        

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/pricing/carrier/{carrier_uuid}", local_var_configuration.base_path, carrier_uuid=crate::apis::urlencode(carrier_uuid));
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }
        if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
            local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
        };

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            let local_var_entity: Option<GetPricingCarrierSuccess> = serde_json::from_str(&local_var_content).ok();
            let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
            Ok(local_var_result)
        } else {
            let local_var_entity: Option<GetPricingCarrierError> = serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// This endpoint will the names of the carriers for which we have data. This can be used to fetch the recency of the data used per carrier.  This endpoint is deprecated. Please use [List Carriers](./getpricingcarriers) instead. 
    async fn get_pricing_carrier_names(&self, ) -> Result<ResponseContent<GetPricingCarrierNamesSuccess>, Error<GetPricingCarrierNamesError>> {
        

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/pricing/version", local_var_configuration.base_path);
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }
        if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
            local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
        };

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            let local_var_entity: Option<GetPricingCarrierNamesSuccess> = serde_json::from_str(&local_var_content).ok();
            let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
            Ok(local_var_result)
        } else {
            let local_var_entity: Option<GetPricingCarrierNamesError> = serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// This endpoint will show the carriers for which we have data. This can be used to fetch the recency of the data used per carrier. 
    async fn get_pricing_carriers(&self, ) -> Result<ResponseContent<GetPricingCarriersSuccess>, Error<GetPricingCarriersError>> {
        

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/pricing/carriers", local_var_configuration.base_path);
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }
        if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
            local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
        };

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            let local_var_entity: Option<GetPricingCarriersSuccess> = serde_json::from_str(&local_var_content).ok();
            let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
            Ok(local_var_result)
        } else {
            let local_var_entity: Option<GetPricingCarriersError> = serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Find the prices offered by a single provider for a specific procedure, with a given insurance, across practice locations.  #### Example Use Case Compare insurance-specific price estimates of a Leg MRI for a single provider at multiple relevant practices (e.g., compare this provider's rates when performing the procedure at both the provider's private outpatient facility, as well as a nearby hospital system clinic where they also practice). 
    async fn get_pricing_provider_procedure(&self,  params: GetPricingProviderProcedureParams ) -> Result<ResponseContent<GetPricingProviderProcedureSuccess>, Error<GetPricingProviderProcedureError>> {
        
        let GetPricingProviderProcedureParams {
            npi,
            procedure_uuid,
            plan_id,
            page,
            page_size,
        } = params;
        

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/pricing/providers/{npi}/procedures/{procedure_uuid}", local_var_configuration.base_path, npi=crate::apis::urlencode(npi), procedure_uuid=crate::apis::urlencode(procedure_uuid));
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = plan_id {
            local_var_req_builder = local_var_req_builder.query(&[("plan_id", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = page {
            local_var_req_builder = local_var_req_builder.query(&[("page", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = page_size {
            local_var_req_builder = local_var_req_builder.query(&[("page_size", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }
        if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
            local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
        };

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            let local_var_entity: Option<GetPricingProviderProcedureSuccess> = serde_json::from_str(&local_var_content).ok();
            let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
            Ok(local_var_result)
        } else {
            let local_var_entity: Option<GetPricingProviderProcedureError> = serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Search for a price estimate for a specific procedure from a specific provider at a specific location, with a given insurance plan.  #### Example Use Case Given an insurance, identify the expected price of a particular procedure from a specific provider at a known facility. 
    async fn get_pricing_provider_procedure_location(&self,  params: GetPricingProviderProcedureLocationParams ) -> Result<ResponseContent<GetPricingProviderProcedureLocationSuccess>, Error<GetPricingProviderProcedureLocationError>> {
        
        let GetPricingProviderProcedureLocationParams {
            npi,
            procedure_uuid,
            location_uuid,
            plan_id,
        } = params;
        

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/pricing/providers/{npi}/procedures/{procedure_uuid}/locations/{location_uuid}", local_var_configuration.base_path, npi=crate::apis::urlencode(npi), procedure_uuid=crate::apis::urlencode(procedure_uuid), location_uuid=crate::apis::urlencode(location_uuid));
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = plan_id {
            local_var_req_builder = local_var_req_builder.query(&[("plan_id", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }
        if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
            local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
        };

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            let local_var_entity: Option<GetPricingProviderProcedureLocationSuccess> = serde_json::from_str(&local_var_content).ok();
            let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
            Ok(local_var_result)
        } else {
            let local_var_entity: Option<GetPricingProviderProcedureLocationError> = serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Fetch the list of procedures that a single provider performs, with the lowest available negotiated rates specific to a given insurance for each procedure.  #### Example Use Case For a given provider, search the full list of procedures that they are likely to perform where there are negotiated rates available for a particular insurance, and return the minimum price for each procedure. 
    async fn get_pricing_provider_procedures(&self,  params: GetPricingProviderProceduresParams ) -> Result<ResponseContent<GetPricingProviderProceduresSuccess>, Error<GetPricingProviderProceduresError>> {
        
        let GetPricingProviderProceduresParams {
            npi,
            plan_id,
            page,
            page_size,
        } = params;
        

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/pricing/providers/{npi}/procedures", local_var_configuration.base_path, npi=crate::apis::urlencode(npi));
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = plan_id {
            local_var_req_builder = local_var_req_builder.query(&[("plan_id", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = page {
            local_var_req_builder = local_var_req_builder.query(&[("page", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = page_size {
            local_var_req_builder = local_var_req_builder.query(&[("page_size", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }
        if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
            local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
        };

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            let local_var_entity: Option<GetPricingProviderProceduresSuccess> = serde_json::from_str(&local_var_content).ok();
            let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
            Ok(local_var_result)
        } else {
            let local_var_entity: Option<GetPricingProviderProceduresError> = serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Search for providers that perform a given procedure and find the lowest insurance-specific price for a procedure in your area.  #### Example Use Case Search for all applicable provider negotiated rates, given a specific insurance and procedure (and optionally, a specific location/address and distance). For example, search for all providers near me who perform Leg MRIs and who take a given insurance, sorted by lowest price. 
    async fn get_pricing_providers(&self,  params: GetPricingProvidersParams ) -> Result<ResponseContent<GetPricingProvidersSuccess>, Error<GetPricingProvidersError>> {
        
        let GetPricingProvidersParams {
            procedure_id,
            procedure,
            procedure_code,
            page,
            page_size,
            plan_id,
            specialty_ids,
            specialty,
            address,
            location,
            distance,
            fields,
            _excl_fields,
        } = params;
        

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/pricing/providers", local_var_configuration.base_path);
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_str) = procedure_id {
            local_var_req_builder = local_var_req_builder.query(&[("procedure_id", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = procedure {
            local_var_req_builder = local_var_req_builder.query(&[("procedure", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = procedure_code {
            local_var_req_builder = local_var_req_builder.query(&[("procedure_code", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = page {
            local_var_req_builder = local_var_req_builder.query(&[("page", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = page_size {
            local_var_req_builder = local_var_req_builder.query(&[("page_size", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = plan_id {
            local_var_req_builder = local_var_req_builder.query(&[("plan_id", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = specialty_ids {
            local_var_req_builder = local_var_req_builder.query(&[("specialty_ids", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = specialty {
            local_var_req_builder = local_var_req_builder.query(&[("specialty", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = address {
            local_var_req_builder = local_var_req_builder.query(&[("address", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = location {
            local_var_req_builder = local_var_req_builder.query(&[("location", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = distance {
            local_var_req_builder = local_var_req_builder.query(&[("distance", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = fields {
            local_var_req_builder = local_var_req_builder.query(&[("fields", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_str) = _excl_fields {
            local_var_req_builder = local_var_req_builder.query(&[("_excl_fields", &local_var_str.to_string())]);
        }
        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }
        if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
            local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
        };

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            let local_var_entity: Option<GetPricingProvidersSuccess> = serde_json::from_str(&local_var_content).ok();
            let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
            Ok(local_var_result)
        } else {
            let local_var_entity: Option<GetPricingProvidersError> = serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
            Err(Error::ResponseError(local_var_error))
        }
    }

    /// Fetch the recency of the pricing data used for a specific carrier by name.  This endpoint is deprecated. Please use [Get Carrier](./getpricingcarrier) instead. 
    async fn get_pricing_version_carrier(&self,  params: GetPricingVersionCarrierParams ) -> Result<ResponseContent<GetPricingVersionCarrierSuccess>, Error<GetPricingVersionCarrierError>> {
        
        let GetPricingVersionCarrierParams {
            carrier_name,
        } = params;
        

        let local_var_configuration = &self.configuration;

        let local_var_client = &local_var_configuration.client;

        let local_var_uri_str = format!("{}/pricing/version/{carrier_name}", local_var_configuration.base_path, carrier_name=crate::apis::urlencode(carrier_name));
        let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

        if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
            local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
        }
        if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
            local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
        };

        let local_var_req = local_var_req_builder.build()?;
        let local_var_resp = local_var_client.execute(local_var_req).await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            let local_var_entity: Option<GetPricingVersionCarrierSuccess> = serde_json::from_str(&local_var_content).ok();
            let local_var_result = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
            Ok(local_var_result)
        } else {
            let local_var_entity: Option<GetPricingVersionCarrierError> = serde_json::from_str(&local_var_content).ok();
            let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
            Err(Error::ResponseError(local_var_error))
        }
    }

}

/// struct for typed successes of method [`get_pricing_carrier`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetPricingCarrierSuccess {
    Status200(models::GetPricingCarriers200ResponseDataInner),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`get_pricing_carrier_names`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetPricingCarrierNamesSuccess {
    Status200(models::GetPricingCarrierNames200Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`get_pricing_carriers`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetPricingCarriersSuccess {
    Status200(models::GetPricingCarriers200Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`get_pricing_provider_procedure`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetPricingProviderProcedureSuccess {
    Status200(models::GetPricingProviderProcedure200Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`get_pricing_provider_procedure_location`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetPricingProviderProcedureLocationSuccess {
    Status200(models::GetPricingProviderProcedureLocation200Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`get_pricing_provider_procedures`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetPricingProviderProceduresSuccess {
    Status200(models::GetPricingProviderProcedures200Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`get_pricing_providers`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetPricingProvidersSuccess {
    Status200(models::GetPricingProviders200Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed successes of method [`get_pricing_version_carrier`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetPricingVersionCarrierSuccess {
    Status200(models::GetPricingVersionCarrier200Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_pricing_carrier`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetPricingCarrierError {
    Status404(models::GetCustomProvider404Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_pricing_carrier_names`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetPricingCarrierNamesError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_pricing_carriers`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetPricingCarriersError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_pricing_provider_procedure`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetPricingProviderProcedureError {
    Status400(models::GetCustomProviders400Response),
    Status404(models::GetCustomProvider404Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_pricing_provider_procedure_location`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetPricingProviderProcedureLocationError {
    Status400(models::GetCustomProviders400Response),
    Status404(models::GetCustomProvider404Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_pricing_provider_procedures`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetPricingProviderProceduresError {
    Status400(models::GetCustomProviders400Response),
    Status404(models::GetCustomProvider404Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_pricing_providers`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetPricingProvidersError {
    Status400(models::GetCustomProviders400Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_pricing_version_carrier`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetPricingVersionCarrierError {
    Status404(models::GetCustomProvider404Response),
    UnknownValue(serde_json::Value),
}

